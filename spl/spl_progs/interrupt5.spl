alias physicalSP S0;
alias System_call_NO S1;	
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
System_call_NO = [physicalSP - 1];
/////////////////////////////////////////////////////////////////////////
/////////////////FORK SYS CALL//////////////////////////////////
/////////////////////////////////////////////////////////////////////
if (System_call_NO==8) then
   alias newPCB S2;
   alias PID S3;
   PID = 0;
   newPCB = READY_LIST;
   ////////////////////Search Readylist of PCBs for STATE 0
   while(PID < 32) do
      if ([ newPCB + 1 ] == 0) then
      	 break;
      endif;
      PID = PID + 1;
      newPCB = newPCB + 32;
   endwhile;
   //////////////////////NO FREE SLOT IN READY LIST OF PCB
   if (PID >= 32) then
      [physicalSP - 2] = -1;
      ireturn;
   endif;
   /////////////CHECK MEM FREE LIST FOR STACK PAGE//////////////////////////////
   alias FreeMemPage S5;
   alias counter S4;
   counter = 0;
   while ([MEM_LIST + counter] >= 1) do
   /////////////////////FAIL IF MEMORY NOT AVAILABLE FOR COPYING PAGES
      if (counter >= 64) then
         [physicalSP - 2] = -1;
      	 ireturn;      	 
      endif;
      counter = counter + 1;
   endwhile;
   FreeMemPage = counter;
////////////////////////////////////////////////////////////////////////////
   ///ASSIGN PID TO PCB SLOT
   [newPCB] = PID;
   //////////////////// UPDATE MEMORY FREE LIST//////////////////////////////
   [MEM_LIST + FreeMemPage] = 1;
   ///////////////////// COPY STACK PAGES ////////////////////////////
   alias Parent_Page S6;
   Parent_Page = [PTBR + 3*2] * 512;
   counter = 0;
   while (counter < 512) do
   	 [FreeMemPage + counter] = [Parent_Page + counter];
	 counter = counter + 1;
   endwhile;
   //////////////////// CALCULATE CHILD PCB //////////////////////////
   alias Child_PTBR S6;
   Child_PTBR = 1024 + PID * 8;
   /////////////////// SET CHILD PAGETABLE (FOR STACK) //////////////////
   [Child_PTBR + 3*2 ] = FreeMemPage;
   [Child_PTBR + 3*2 + 1] = "01";
   //////////SETUPING PAGE TABLE FOR CHILD PROCESS
   alias page_Num S7;
   counter = 0;
   page_Num = 0;
   while(counter < 3) do
      page_Num = [PTBR + counter*2];
      if ([PTBR + 2*counter + 1]%10 == 1) then
	  [MEM_LIST + page_Num] = [MEM_LIST + page_Num] + 1;
      else
	if (page_Num >= 448) then
	   [DISK_LIST + page_Num] = [DISK_LIST + page_Num] + 1;
	endif;
      endif;
      [Child_PTBR + counter*2] = [PTBR + counter*2];
      [Child_PTBR + counter*2 + 1] =  [PTBR + counter*2 + 1];
      counter = counter + 1;
   endwhile;
   ////STORE DISK FREE LIST BACK TO DISK////////////
   store(6, 20);
   /////////setup pcb for child process////////////////////
   [newPCB + 5] = Child_PTBR;
   [newPCB + 4] = [physicalSP];
   [newPCB + 3] = (SP - 1);
   [newPCB + 2] = BP;
   [newPCB + 6] = PTLR;
   [newPCB + 7] = R0;
   [newPCB + 8] = R1;
   [newPCB + 9] = R2;
   [newPCB + 10] = R3;
   [newPCB + 11] = R4;
   [newPCB + 12] = R5;
   [newPCB + 13] = R6;
   [newPCB + 14] = R7;
   //////////////////COPING PER PROCESS OPEN FILE TABLE///////////////
   alias CurrentPID S5;
   CurrentPID = (PTBR - 1024)/8;
   alias CurrentPCB S6;
   alias FileIndex S7;
   CurrentPCB = READY_LIST + 32*CurrentPID;
   counter = 15;
   while (counter <= 30) do
      FileIndex = [CurrentPCB + counter];
      [newPCB + counter] = FileIndex;
      if (FileIndex!= -1) then
      	 [FILE_TABLE + 2*FileIndex + 1] = [FILE_TABLE + 2*FileIndex + 1] + 1;
      endif;
      [newPCB + counter + 1] = [CurrentPCB + counter + 1];
      counter = counter + 2;
   endwhile;
   [newPCB + 31] = CurrentPID; //////storing parent pid
   [physicalSP - 2] = PID;
   ////FINDING PHYSICAL SP FOR CHILD PROCESSS
   ////AND GIVING RETURN VALUE -2  FOR CHILD
   physicalSP = ([1024 + (PID*8) + 2 * ((SP-1) / 512)] * 512) + ((SP-1) % 512);
   [physicalSP - 1] = -2;
   [newPCB + 1] = 1;
   ireturn;
endif;