alias physicalSP S0;
alias System_call_NO S1;	
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
System_call_NO = [physicalSP - 1];
/////////////////////////////////////////////////////////////////////////
/////////////////FORK SYS CALL//////////////////////////////////
/////////////////////////////////////////////////////////////////////
if (System_call_NO==8) then
   alias newPCB S2;
   alias PID S3;
   PID = 0;
   newPCB = READY_LIST;
   ////////////////////Search Readylist of PCBs for STATE 0
   while(PID < 32) do
      if ([ newPCB + 1 ] == 0) then
      	 break;
      endif;
      PID = PID + 1;
      newPCB = newPCB + 32;
   endwhile;
   //////////////////////NO FREE SLOT IN READY LIST OF PCB
   if (PID >= 32) then
      [physicalSP - 2] = -1;
      ireturn;
   endif;
   /////////////CHECK MEM FREE LIST FOR STACK PAGE//////////////////////////////
   alias FreeMemPage S5;
   alias counter S4;
   counter = 0;
   while ([MEM_LIST + counter] == 1) do
   /////////////////////FAIL IF MEMORY NOT AVAILABLE FOR COPYING PAGES
      if (Num_Page >= 64) then
         [physicalSP - 2] = -1;
      	 ireturn;      	 
      endif;
      counter = counter + 1;
   endwhile;
   FreeMemPage = counter
////////////////////////////////////////////////////////////////////////////
   ///ASSIGN PID TO PCB SLOT
   [newPCB] = PID;
   //////////////////// UPDATE MEMORY FREE LIST//////////////////////////////
   [MEM_LIST + FreeMemPage] = 1;
   ///////////////////// COPY STACK PAGES ////////////////////////////
   alias Parent_Page S6;
   Parent_Page = [PTBR + 3*2] * 512;
   counter = 0;
   while (counter < 512) do
   	 [FreeMemPage + counter] = [Parent_Page + counter];
	 counter = counter + 1;
   endwhile;
   //////////////////// CALCULATE CHILD PCB //////////////////////////
   alias Child_PTBR S6;
   Child_PTBR = 1024 + PID * 8;
   //////////SETUPING PAGE TABLE FOR CHILD PROCESS 
   counter = 0;
   Valid_page = 0;
   while(counter< PTLR) do
      if ([PTBR + 2*counter]==-1) then
        [Child_PTBR + counter*2] = -1;
      else
	[Child_PTBR + counter*2] =  [SCRATCHPAD + Valid_page];
	Valid_page = Valid_page + 1;
      endif;
      [Child_PTBR + counter*2 + 1] =  [PTBR + counter*2 + 1];
      counter = counter + 1;
   endwhile;
   /////////SETUP PCB FOR CHILD PROCESS////////////////////
   [newPCB + 5] = Child_PTBR;
   [newPCB + 4] = [physicalSP];
   [newPCB + 3] = (SP - 1);
   [newPCB + 2] = BP;
   [newPCB + 6] = PTLR;
   [newPCB + 7] = R0;
   [newPCB + 8] = R1;
   [newPCB + 9] = R2;
   [newPCB + 10] = R3;
   [newPCB + 11] = R4;
   [newPCB + 12] = R5;
   [newPCB + 13] = R6;
   [newPCB + 14] = R7;
   //////////////////COPING PER PROCESS OPEN FILE TABLE///////////////
   alias CurrentPID S5;
   CurrentPID = (PTBR - 1024)/8;
   alias CurrentPCB S6;
   alias FileIndex S7;
   CurrentPCB = READY_LIST + 32*CurrentPID;
   counter = 15;
   while (counter <= 30) do
      FileIndex = [CurrentPCB + counter];
      [newPCB + counter] = FileIndex;
      if (FileIndex!= -1) then
      	 [FILE_TABLE + 2*FileIndex + 1] = [FILE_TABLE + 2*FileIndex + 1] + 1;
      endif;
      [newPCB + counter + 1] = [CurrentPCB + counter + 1];
      counter = counter + 2;
   endwhile;
   [newPCB + 31] = CurrentPID; //////storing parent pid
   [physicalSP - 2] = PID;
   ////FINDING PHYSICAL SP FOR CHILD PROCESSS
   ////AND GIVING RETURN VALUE -2  FOR CHILD
   physicalSP = ([1024 + (PID*8) + 2 * ((SP-1) / 512)] * 512) + ((SP-1) % 512);
   [physicalSP - 1] = -2;
   [newPCB + 1] = 1;
   ireturn;
endif;