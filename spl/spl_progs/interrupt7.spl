alias physicalSP S0;
alias System_call_NO S1;
physicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
System_call_NO = [physicalSP - 1];
alias currentPID S3;
currentPID = (PTBR - 1024) / 8;
///////////////////////////////////////////////////////////////////////////
///////////////// EXIT SYS CALL////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
if (System_call_NO == 10) then
   alias Current_PCB S2;
   alias counter S4;
   alias flag S5;
   flag = 0;
   counter = 0;
   Current_PCB = READY_LIST;
   ///////FINDING RUNNING AND READY PROCESS///////////////
   while(counter < 32) do
   	 if ([ Current_PCB + 1 ] == (100 + currentPID)) then
	    [Current_PCB + 1] = 1;
	 endif;
	 if ([Current_PCB + 1 ] == 1) then
	    flag = 1;
	 endif;
	 counter = counter + 1;
	 Current_PCB = Current_PCB + 32;
   endwhile;
   ////////////HALT IN CASE OF NO READY PROCESS///////////////
   if (flag == 0 ) then
      print "No ready";
      print "process";
      halt;
   endif;
   Current_PCB = READY_LIST + 32 * currentPID;
   ////////////////CLOSING ALL FILES OPENED BY RUNNING(CURRENT) PROCESS
   alias FileIndex S3;
   ///// FINDING INDEX TO SYSTEM WIDE OPEN FILE ENTRY///////////
   counter = 0;
   while(counter < 8) do
      if ([Current_PCB + 15 + 2*counter]== -1) then
         counter = counter + 1;
         continue;
      else
         FileIndex = [Current_PCB + 15 + 2*counter];
      endif;
      ////////REDUCE NUMBER OF OPEN FILES BY 1/////////////////
      [ FILE_TABLE + FileIndex + 1] = [ FILE_TABLE + FileIndex + 1] - 1;
//////INVALIDATE FAT INDEX IN SYS WIDE OPEN FILE TABLE IN CASE OF OPEN FILES ARE ZERO
      if ([ FILE_TABLE + FileIndex + 1] == 0) then
      	 [ FILE_TABLE + FileIndex] = -1;
      endif;
      /////INVALIDATING PER PROCESS FILE TABLE
      [Current_PCB + 15 + 2*counter] = -1;
      [Current_PCB + 15 + 2*counter + 1] = -1;
      counter = counter + 1;
   endwhile;
   //////////////////////SETTING STATE TO TERMINATED/////////////////
   [Current_PCB + 1 ] = 0;
   ////////FREEING PAGES USED BY CURRENT PROCESS AND INVALIDATING PAGE TABLE////////
   counter = 0;
   alias page_NO S3;
   while(counter < PTLR) do
      page_NO = [PTBR + counter*2];
      if (page_NO!=-1) then
      	 [MEM_LIST + page_NO] = 0;
      endif;
      [PTBR + counter*2]=-1;
      [PTBR + counter*2 + 1]="00";
      counter = counter + 1;
   endwhile;
endif;

/////////////////////////////////////////////////////////////
////////////////Wait SYS call //////////////////////////////
////////////////////////////////////////////////////////////
if (System_call_NO == 13) then
   alias Sema_ID S2;
   Sema_ID = [physicalSP - 3];
   alias SemaPCB S4;
   ////Check for valid SEMA_ID
   if ((Sema_ID > 31) || (Sema_ID < 0)) then
    	[physicalSP - 2] = -1;
	print "Invalid";
	print "SEMA ID";
    	ireturn;
   endif;
   SemaPCB = READY_LIST + 32 * Sema_ID;
   if ([SemaPCB + 1] == 0) then
      [physicalSP - 2] = -1;
      ireturn;
   endif;
   if ([1472 + Sema_ID] == 0) then
      alias CurrentPCB S5;
      CurrentPCB = READY_LIST + 32 * currentPID;
      [CurrentPCB + 1] = 100 + Sema_ID;
      [ CurrentPCB + 2 ] = BP;
      [ CurrentPCB + 3 ] = SP - 1;
      [ CurrentPCB + 4 ] = [physicalSP]; // Save IP of current process in the PCB from the stack
      //set PTBR and PTLR fields of the PCB with the values in PTBR and PTLR
      [ CurrentPCB + 5 ] = PTBR; 
      [ CurrentPCB + 6 ] = PTLR;
      //save the registers R0 to R7 in the respective fields of the PCB.
      [ CurrentPCB + 7 ] = R0;
      [ CurrentPCB + 8 ] = R1;
      [ CurrentPCB + 9 ] = R2;
      [ CurrentPCB + 10 ] = R3;
      [ CurrentPCB + 11 ] = R4;
      [ CurrentPCB + 12 ] = R5;
      [ CurrentPCB + 13 ] = R6; 
      [ CurrentPCB + 14 ] = R7;
      [physicalSP - 2] = 0;
   else
      [1472 + Sema_ID] = [1472 + Sema_ID] - 1;
      [physicalSP - 2] = 0;
      ireturn;
   endif;
endif;
//////////////////////////////////////////////////////////////////////
/////////////////Signal SYS call//////////////////////////////////
//////////////////////////////////////////////////////////////////
if (System_call_NO == 14) then
   alias counter S2;
   counter = 0;
   alias Current_PCB S4;
   alias Sema_ID S5;
   alias SemaPCB S6;
   alias SID S7;
   Sema_ID = [physicalSP - 3];
   ////Check for valid SEMA_ID
   if ((Sema_ID > 31) || (Sema_ID < 0)) then
        print "Invalid";
	print "SEMA ID";
    	[physicalSP - 2] = -1;
    	ireturn;
   endif;   
   SemaPCB = READY_LIST + 32 * Sema_ID;
   if ([SemaPCB + 1] == 0) then
      print "TERMINATED";
      print "SEMA ID";
      [physicalSP - 2] = -1;
      ireturn;
   endif;
   Current_PCB =  READY_LIST + currentPID;
   SID = currentPID;
   while(counter < 32) do
   	 if ([Current_PCB + 1] == (100 + Sema_ID)) then
	    [Current_PCB + 1] = 1;
       	    [physicalSP - 2] = 0;
      	    ireturn;	    
	 endif;	
	 counter = counter + 1;
	 SID = (SID+1)%32;
	 Current_PCB = (READY_LIST + SID*32);
   endwhile;
   if (counter == 32) then
      [1472 + Sema_ID] = [1472 + Sema_ID] + 1;   
   endif;
   [physicalSP - 2] = 0;
   ireturn;
endif;
///////////////////////////////////////////////////////////////////////
//////////////////SCHEDULER for next process///////////////////////////
/////////////////////////////////////////////////////////////////////
alias newPCB S4;
alias NextPID S5;
NextPID = currentPID;
newPCB = READY_LIST + 32 * (currentPID);
alias counter S6;
counter = 0;
while(counter < 32) do
	 if ([ newPCB + 1 ] == 1) then
	    break;
	 endif;
	 NextPID = (NextPID + 1) % 32;
	 newPCB = READY_LIST + 32 * (NextPID);
	 counter = counter + 1;
endwhile;
if (counter == 32) then
     [physicalSP - 2] = -1;
     print "No ready";
     print "process";
     halt;
endif;
/////////////////////////RESTORING STATE FOR NEXT PID///////////////////////
BP = [ newPCB + 2 ];
SP = [ newPCB + 3 ];
//set PTBR and PTLR fields of the PCB with the values in PTBR and PTLR
PTBR = [ newPCB + 5 ];
PTLR = [ newPCB + 6 ];
//save the registers R0 to R7 in the respective fields of the PCB.
R0 = [ newPCB + 7 ];
R1 = [ newPCB + 8 ];
R2 = [ newPCB + 9 ];
R3 = [ newPCB + 10 ];
R4 = [ newPCB + 11 ];
R5 = [ newPCB + 12 ];
R6 = [ newPCB + 13 ];
R7 = [ newPCB + 14 ];
SP = SP + 1;///DUE DO IP IN THE TOP OF STACK 
alias newphysicalSP S2;
newphysicalSP = ([PTBR + 2 * (SP / 512)] * 512) + (SP % 512);
[ newphysicalSP ] = [ newPCB + 4 ]; // Stores IP field value of PCB on the stack
[ newPCB + 1 ] = 2; // Set STATE to RUNNING
ireturn;
